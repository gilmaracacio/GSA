<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Visualizador MapView 360 com Heatmap, Legenda e Busca de Localidades</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; font-family: 'Arial', sans-serif; background: #f5f5f5; }
    #map { width: 100%; height: 100%; }

    /* Buscadores deslocados à direita */
    .search-box {
      position: absolute; top: 10px; left: 150px;
      background: white; padding: 8px 12px; border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25); z-index: 1000;
      display: flex; flex-direction: column; gap: 6px;
    }
    .search-box input {
      border: 1px solid #ccc; border-radius: 6px; padding: 4px 8px;
      outline: none; min-width: 220px;
    }
    .search-box button {
      background: #0078ff; color: white; border: none;
      border-radius: 6px; padding: 4px 10px; cursor: pointer;
    }
    .search-box button:hover { background: #005fcc; }

   



 /* Legenda com borda colorida */
    .legend {
      line-left: 18px; color: #333; background: white;
      padding: 8px; border-radius: 8px;
      border: 3px solid #0078ff; 
      box-shadow: 0 2px 6px rgba(0,0,0,0.25); font-size: 13px;
      position: absolute;
      top: 250px;
      left: -100px;
      z-index: 1000;
    }
    .legend i {
      width: 14px; height: 14px; float: left;
      margin-right: 6px; opacity: 0.9; border-radius: 50%;
    }
  </style>
</head>




<body>
  <div class="search-box">
    <!-- Localizador de códigos -->
    <div>
      <input type="text" id="searchInput" placeholder="Digite o código..." list="codigosDisponiveis">
      <datalist id="codigosDisponiveis"></datalist>
      <button onclick="buscarRegistro()">Buscar</button>
    </div>

   

 <!-- Localizador de localidades do Google -->
    <div>
      <input id="googlePlacesInput" type="text" placeholder="Digite uma localidade...">
      <button onclick="buscarLocalidade()">Ir para Localidade</button>
    </div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

  <!-- Google Places API -->
  <script src="https://maps.googleapis.com/maps/api/js?key=SEU_API_KEY&libraries=places"></script>

 

 <script>
    const map = L.map('map').setView([-14.2350, -51.9253], 4);

   

 // Mapas base
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 22, attribution: '&copy; OpenStreetMap contributors' });
    const google = L.tileLayer('https://mt1.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', { maxZoom: 22 });
    const positron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { maxZoom: 22, attribution: '&copy; CartoDB' }).addTo(map);

    L.control.layers({
      "OpenStreetMap": osm,
      "Google Maps": google,
      "CartoDB (Cinza)": positron
    }).addTo(map);

    // Temática
    const thematic = {
      "buraco": { color: "red", radius: 12 },
      "trinca": { color: "orange", radius: 14 },
      "afundamento": { color: "blue", radius: 16 },
      "ondulação": { color: "green", radius: 18 }
    };

    const circleMap = {};
    const datalist = document.getElementById("codigosDisponiveis");
    const csvUrl = 'https://raw.githubusercontent.com/gilmaracacio/GSA/main/BASETS.csv';

    // Camadas por tipo
    const typeLayers = {};
    Object.keys(thematic).forEach(t => {
      typeLayers[t] = L.layerGroup().addTo(map);
    });

    // Parse CSV
    function parseCSV(csvText) {
      const lines = csvText.trim().split('\n');
      const headers = lines[0].split(',').map(h => h.trim());
      const features = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g) || [];
        if (values.length < 6) continue;
        const props = {};
        headers.forEach((h, idx) => {
          if (values[idx]) props[h] = values[idx].replace(/^"|"$/g, '').trim();
        });
        const lat = parseFloat(props.lat), lon = parseFloat(props.lon);
        if (!isNaN(lat) && !isNaN(lon)) {
          features.push({ coords: [lat, lon], props });
        }
      }
      return features;
    }

    // Criar marcadores + heatmap
    function createMarkers(features) {
      const heatPoints = [];

      features.forEach(f => {
        const center = f.coords;
        const p = f.props;
        const style = thematic[p.tipo] || { color: "gray", radius: 10 };

        const circle = L.circleMarker(center, {
          radius: style.radius, color: style.color,
          weight: 2, fillOpacity: 0.75, fillColor: style.color
        });

        circle.bindPopup(`
          <b>Tipo:</b> ${p.tipo}<br>
          <b>Código:</b> ${p.codigo}<br>
          <b>Estatus:</b> ${p.Estatus}<br>
          <b>Dado 1:</b> ${p.dado1}<br>
          <b>Dado 2:</b> ${p.dado2}<br>
          <b>Responsável:</b> ${p.responsavel}<br>
          <b>Data:</b> ${p.data}
        `);

        circle.featureTipo = p.tipo;
        circleMap[p.codigo] = circle;

        if (typeLayers[p.tipo]) typeLayers[p.tipo].addLayer(circle);

        heatPoints.push([center[0], center[1], 0.3]);

        const opt = document.createElement("option");
        opt.value = p.codigo;
        datalist.appendChild(opt);
      });

      const heatLayer = L.heatLayer(heatPoints, {
        radius: 50, blur: 35, maxZoom: 12,
        gradient: {0.3:'rgba(0,0,255,0.4)',0.5:'lime',0.7:'orange',0.9:'red'}
      }).addTo(map);

      L.control.layers(null, { "Zonas de Concentração": heatLayer }).addTo(map);
    }

    // Legenda interativa
    const legendControl = L.control({ position: 'topright' });

    legendControl.onAdd = function(map) {
      const div = L.DomUtil.create('div', 'legend');
      div.innerHTML = '<strong>Tipos:</strong><br>';
      Object.keys(thematic).forEach(t => {
        const label = document.createElement("label");
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        label.style.gap = '6px';
        label.innerHTML = `<input type="checkbox" checked data-type="${t}"> <i style="background:${thematic[t].color}"></i> ${t}`;
        div.appendChild(label);
      });
      L.DomEvent.disableClickPropagation(div);
      return div;
    };

    legendControl.addTo(map);

    document.addEventListener('change', function(e){
      if(e.target && e.target.tagName === 'INPUT' && e.target.dataset.type){
        const type = e.target.dataset.type;
        if(e.target.checked){
          map.addLayer(typeLayers[type]);
        } else {
          map.removeLayer(typeLayers[type]);
        }
      }
    });

    // Buscar registro
    function buscarRegistro() {
      const code = document.getElementById("searchInput").value.trim();
      if (circleMap[code]) {
        map.setView(circleMap[code].getLatLng(), 18);
        circleMap[code].openPopup();
      } else {
        alert("Registro não encontrado!");
      }
    }

    // Buscar localidade Google
    let autocomplete;
    function initAutocomplete() {
      const input = document.getElementById('googlePlacesInput');
      autocomplete = new google.maps.places.Autocomplete(input);
      autocomplete.addListener('place_changed', () => {
        const place = autocomplete.getPlace();
        if (place.geometry && place.geometry.location) {
          const lat = place.geometry.location.lat();
          const lng = place.geometry.location.lng();
          map.setView([lat, lng], 15);
        }
      });
    }
    function buscarLocalidade() {
      const place = autocomplete.getPlace();
      if (place && place.geometry && place.geometry.location) {
        const lat = place.geometry.location.lat();
        const lng = place.geometry.location.lng();
        map.setView([lat, lng], 15);
      } else {
        alert("Localidade não encontrada!");
      }
    }

    // Inicializa Google Autocomplete após carregar script
    window.onload = initAutocomplete;

    // Carregar CSV
    fetch(csvUrl).then(r => r.text())
      .then(data => {
        const features = parseCSV(data);
        createMarkers(features);
        map.fitBounds(L.featureGroup(Object.values(circleMap)).getBounds());
      })
      .catch(err => console.error("Erro ao carregar CSV:", err));
  </script>
</body>
</html>
